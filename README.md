# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

# Найденные проблемы и их решения

## Проблема 1

Создавая Service Worker, мы должны помнить о том, что у каждого SW есть свое пространство (scope), на котором он работает. По умолчанию, его scope будет директория, в которой данный SW лежит. Стоит заметить, что scope нельзя изменить на уровень выше, только на уровень(-ни) ниже.

В данном случае, проект имеет helper `service-worker`, расположенный в файле `assets/blocks.js`, который регистрирует SW `assets/service-worker.js`. Соответственно, . Для того, чтобы SW работал правильно, можно воспользоваться следующим решением:

Перенести `assets/service-worker.js` в корень проекта, при этом изменив путь к SW в `assets/blocks.js`.

## Проблема 2

Ресурсы приложения не кэшируется для offline-режима. Будем кэшировать ресурсы на этапе установки SW, так мы добъемся еще и возможность переключения в offline-режим сразу после первого запроса.

## Проблема 3

Невозможно обновить ресурсы приложения. Так как ключем главного кэша является константа CACHE_VERSION, все, что требуется сделать для обновления HTML / CSS / JS - это изменить данный ключ, например, c `1.0.0-broken` на `1.0.1`.

Далее нужно ждать пока браузер обновит Service Worker.

## Проблема 4

Gif не добавляется в кэш из результата поиска, когда интернет отключен. Добавление новой картинки в избранное происходит в функции `handleFavoriteAdd`. В нее нужно добавить обработчик, который будет добавлять незагрузившиеся запросы в массив `cacheFail`.

## Проблема 5

При удалении gif-картинки они остаются в кэше (это можно видеть на вкладке Application > Cache Storage в DevTools). Добавим обработчик удаления картинки из избранного.

Данный обработчик имеет имя `favorite:remove`, которое задается ему в файле `assets/blocks.js`, 483 строка. Следовательно, в `service-worker.js` в объекте `messageHandlers` мы должны использовать такой же ключ.

# Ответы на вопросы в файлах

## Вопрос №1: зачем нужен вызов `self.skipWaiting()`?

`skipWaiting` относится к жизненному циклу Service Worker. Жизненный цикл SW состоит из четырех этапов: установка, ожидание, активация и непосредственная работа. Как только, произошла установка SW на странице, он попадает в этап ожидания, который завершается только тогда, когда предыдущий SW (если он есть) закончит свою работу. После ожидания, он проходит стадию активации и затем работает.

Метод Service Worker `skipWaiting` позволяет обойти данную структуру цикла. После того, как произошла установка нового SW, он начинает работать немедленно, не дожидаясь завершения работы предыдущего SW.

Подробнее на [MDN](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting).

## Вопрос №2: зачем нужен вызов `self.clients.claim()`?

После прохождения первых трех стадий жизненного цикла, Service Worker не станет работать немедленно. Он начнет выполнять свой функционал только после повторной загрузки страницы. Метод `self.clients.claim()` позволяет переопредилить данное поведение так, что SW начнет работать сразу после первой загрузки страницы.

Подробнее на [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim).

## Вопрос №3: для всех ли случаев подойдёт такое построение ключа?

```
const key = url.origin + url.pathname;
```

Нет, не для всех. Данный ключ отлично подходит под статические адреса, т.е.

 * https://localhost/assets/blocks.js
 * https://localhost/assets/star.svg
 * https://localhost/gifs.html

Однако, если адрес будет содержать GET-параметры (например, `?text=3&param=-1`), то такой ключ по своему построению не будет учитывать их (`url.search`).

## Вопрос №4: зачем нужна эта цепочка вызовов?

```
return Promise.all(
  names.filter(name => name !== CACHE_VERSION)
    .map(name => {
      console.log('[ServiceWorker] Deleting obsolete cache:', name);
      return caches.delete(name);
    })
);
```

Главное кэш-хранилище в данном приложении задается ключем, хранящимся в `CACHE_VERSION`. Если нам нужно обновить статические файлы, хранящиеся в кэше, мы всего лишь должны изменить ключ `CACHE_VERSION`.

В данном куске кода, с помощью функции `filter` отбираются те главные кэш-хранилища, которые не совпадают с текущим названием кэш-хранилища (проще говоря, старые кэши). Затем они удаляются с помощью `caches.delete()`.

Подробнее на MDN:

 * [filter](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
 * [map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
 * [Cache.delete()](https://developer.mozilla.org/en-US/docs/Web/API/Cache/delete)

## Вопрос №5: для чего нужно клонирование?

```
cache.put(cacheKey, response.clone())
```

Согласно [документации MDN](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers#Recovering_failed_requests), потоки Request и Response могут быть прочитаны только единожды. Поэтому мы создаем клон-объект Response, отдавая его кэшу, а оригинальный объект Response возвращается браузеру: `.then(() => response)`.

В документации к [Response API](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) объясняется, что единственная причина существования `clone()` - это разрешить множественное использование объектов `Body`.

## Доп. вопрос: нужно ли при скачивании сохранять ресурс для оффлайна?

```
function needStoreForOffline(cacheKey) {
   return cacheKey.includes('vendor/') ||
       cacheKey.includes('assets/') ||
       cacheKey.endsWith('jquery.min.js');
}
```

От данного куска кода пришлось отказаться в ходе решения задачи. Теперь мы сохраняем ресурсы для оффлайна на этапе регистрации Service Worker для того, чтобы разрешить offline-режим сразу же после первой загрузки страницы.